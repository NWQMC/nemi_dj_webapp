# -*- coding: utf-8 -*-
# Generated by Django 1.11.5 on 2018-09-26 11:42
from __future__ import unicode_literals

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('reference', '__first__'),
    ]

    operations = [
        migrations.CreateModel(
            name='AnalyteMethodJn',
            fields=[
                ('analyte_method_id', models.AutoField(primary_key=True, serialize=False)),
                ('dl_value', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('accuracy', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('false_positive_value', models.IntegerField(blank=True, null=True)),
                ('false_negative_value', models.IntegerField(blank=True, null=True)),
                ('precision', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('prec_acc_conc_used', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('insert_date', models.DateField(blank=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50, null=True)),
                ('last_update_date', models.DateField(blank=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, max_length=50, null=True)),
                ('green_flag', models.CharField(blank=True, max_length=1, null=True)),
                ('yellow_flag', models.CharField(blank=True, max_length=1, null=True)),
                ('confirmatory', models.CharField(blank=True, choices=[('Yes', 'Yes'), ('No', 'No'), ('Possibly', 'Possibly'), ('N/A', 'N/A')], max_length=8, null=True)),
                ('date_loaded', models.DateField(blank=True, null=True)),
                ('accuracy_units', models.ForeignKey(blank=True, db_column='accuracy_units', null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='reference.AccuracyUnitsDom')),
                ('analyte', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='reference.AnalyteRef')),
            ],
            options={
                'verbose_name': 'method analyte',
                'db_table': 'analyte_method_jn',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AnalyteMethodJnOnline',
            fields=[
                ('analyte_method_id', models.AutoField(primary_key=True, serialize=False)),
                ('dl_value', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('accuracy', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('false_positive_value', models.IntegerField(blank=True, null=True)),
                ('false_negative_value', models.IntegerField(blank=True, null=True)),
                ('precision', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('prec_acc_conc_used', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('insert_date', models.DateField(blank=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50, null=True)),
                ('last_update_date', models.DateField(blank=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, max_length=50, null=True)),
                ('green_flag', models.CharField(blank=True, max_length=1, null=True)),
                ('yellow_flag', models.CharField(blank=True, max_length=1, null=True)),
                ('confirmatory', models.CharField(blank=True, choices=[('Yes', 'Yes'), ('No', 'No'), ('Possibly', 'Possibly'), ('N/A', 'N/A')], max_length=8, null=True)),
                ('reviewer_name', models.CharField(blank=True, max_length=100, null=True)),
                ('accuracy_units', models.ForeignKey(blank=True, db_column='accuracy_units', null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='reference.AccuracyUnitsDom')),
                ('analyte', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='reference.AnalyteRef')),
            ],
            options={
                'verbose_name': 'method analyte',
                'db_table': 'analyte_method_jn_online',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AnalyteMethodJnStg',
            fields=[
                ('analyte_method_id', models.AutoField(primary_key=True, serialize=False)),
                ('dl_value', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('accuracy', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('false_positive_value', models.IntegerField(blank=True, null=True)),
                ('false_negative_value', models.IntegerField(blank=True, null=True)),
                ('precision', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('prec_acc_conc_used', models.DecimalField(blank=True, decimal_places=6, max_digits=15, null=True)),
                ('insert_date', models.DateField(blank=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50, null=True)),
                ('last_update_date', models.DateField(blank=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, max_length=50, null=True)),
                ('green_flag', models.CharField(blank=True, max_length=1, null=True)),
                ('yellow_flag', models.CharField(blank=True, max_length=1, null=True)),
                ('confirmatory', models.CharField(blank=True, choices=[('Yes', 'Yes'), ('No', 'No'), ('Possibly', 'Possibly'), ('N/A', 'N/A')], max_length=8, null=True)),
                ('date_loaded', models.DateField(blank=True, null=True)),
                ('accuracy_units', models.ForeignKey(blank=True, db_column='accuracy_units', null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='reference.AccuracyUnitsDom')),
                ('analyte', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='reference.AnalyteRef')),
            ],
            options={
                'verbose_name': 'method analyte',
                'db_table': 'analyte_method_jn_stg',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='AnalyteSummaryVW',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('dl_units', models.CharField(blank=True, max_length=5)),
                ('dl_value', models.DecimalField(decimal_places=6, max_digits=15, null=True)),
                ('accuracy', models.DecimalField(decimal_places=6, max_digits=15, null=True)),
                ('accuracy_units', models.CharField(blank=True, max_length=40)),
                ('precision', models.DecimalField(decimal_places=6, max_digits=15, null=True)),
                ('precision_units', models.CharField(blank=True, max_length=30)),
                ('prec_acc_conc_used', models.DecimalField(decimal_places=6, max_digits=15, null=True)),
                ('false_positive_value', models.IntegerField(null=True)),
                ('false_negative_value', models.IntegerField(null=True)),
                ('analyte_code', models.CharField(blank=True, max_length=20)),
                ('analyte_name', models.CharField(blank=True, max_length=240)),
                ('dl_units_description', models.CharField(blank=True, max_length=60)),
                ('precision_units_description', models.CharField(blank=True, max_length=100)),
                ('accuracy_units_description', models.CharField(blank=True, max_length=50)),
                ('precision_descriptor_notes', models.CharField(blank=True, max_length=3000)),
                ('dl_note', models.CharField(blank=True, max_length=2000)),
                ('preferred', models.IntegerField(blank=True)),
                ('method_id', models.IntegerField(null=True)),
            ],
            options={
                'db_table': 'analyte_summary_vw',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='DefinitionsDOM',
            fields=[
                ('definition_name', models.CharField(max_length=75, primary_key=True, serialize=False)),
                ('definition_description', models.CharField(max_length=1500)),
                ('definition_abbrev', models.CharField(max_length=30)),
                ('web_desc_bio', models.CharField(blank=True, max_length=4000)),
                ('web_desc_all', models.CharField(blank=True, max_length=4000)),
                ('web_desc_phys', models.CharField(blank=True, max_length=4000)),
                ('column_help', models.CharField(blank=True, max_length=4000)),
            ],
            options={
                'db_table': 'definitions_dom',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='DlRef',
            fields=[
                ('dl_type_id', models.IntegerField(primary_key=True, serialize=False, unique=True)),
                ('dl_type', models.CharField(max_length=11, unique=True)),
                ('dl_type_description', models.CharField(max_length=50, unique=True)),
            ],
            options={
                'db_table': 'dl_ref',
                'ordering': ('dl_type',),
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='DlUnitsDom',
            fields=[
                ('dl_units', models.CharField(max_length=20, primary_key=True, serialize=False, unique=True)),
                ('dl_units_description', models.CharField(blank=True, max_length=60)),
            ],
            options={
                'db_table': 'dl_units_dom',
                'ordering': ('dl_units',),
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='InstrumentationRef',
            fields=[
                ('instrumentation_id', models.IntegerField(primary_key=True, serialize=False)),
                ('instrumentation', models.CharField(max_length=20)),
                ('instrumentation_description', models.CharField(max_length=200)),
            ],
            options={
                'db_table': 'instrumentation_ref',
                'ordering': ('instrumentation_description',),
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='LegacyUserAccount',
            fields=[
                ('user_seq', models.FloatField(primary_key=True, serialize=False)),
                ('user_name', models.CharField(max_length=100, unique=True)),
                ('user_password', models.TextField(blank=True, null=True)),
                ('email', models.CharField(max_length=200, unique=True)),
                ('forgot_pw_flag', models.CharField(max_length=1)),
                ('data_entry_name', models.CharField(max_length=100)),
                ('data_entry_date', models.DateField()),
                ('last_update_name', models.CharField(blank=True, max_length=100, null=True)),
                ('last_update_date', models.DateField(blank=True, null=True)),
                ('first_name', models.CharField(max_length=100)),
                ('last_name', models.CharField(max_length=200)),
                ('organization', models.CharField(blank=True, max_length=1000, null=True)),
                ('last_login', models.DateField(blank=True, null=True)),
                ('user_status', models.CharField(max_length=40)),
            ],
            options={
                'db_table': 'user_account',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='MediaNameDOM',
            fields=[
                ('media_name', models.CharField(max_length=30, primary_key=True, serialize=False)),
                ('media_id', models.IntegerField()),
            ],
            options={
                'db_table': 'media_name_dom',
                'ordering': ['media_name'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='Method',
            fields=[
                ('insert_date', models.DateField(blank=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50)),
                ('last_update_date', models.DateField(blank=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, max_length=50)),
                ('approved', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', max_length=1)),
                ('approved_date', models.DateField(blank=True, null=True)),
                ('source_method_identifier', models.CharField(help_text='The method number / identifier can be numerical (e.g., 375.4), numerical w/text (e.g., 4500-SO4 C) or all text (e.g., Simplate). NOTE: If your method number ends in a "0" (e.g., 300.0), please contact the NEMI manager (entries ending in "0" are automatically truncated in Excel, and must be fixed by the NEMI manager).\nWhatever the format, you must choose a unique method number for your method. Also, keep things specific; do not use "Not Applicable," "Color Method" or something of that nature. If your method does not have a unique identifier, you must create one -- consider using a document number (e.g., EPA-XX-X-XXXX), product number, etc..\nIF a method has a published method number THEN include it ELSE create one', max_length=30, unique=True, verbose_name='method number/identifier')),
                ('method_descriptive_name', models.CharField(blank=True, help_text='This field is designed to provide the user with a quick identification of a method, so include the analyte (ex: "nitrate") or group of analytes (ex; "nutrients"), the matrix (ex: "in water"), and instrumentation (ex: "using colorimetry"):\nEx. 1: Nitrate in Water by Colorimetry\nEx. 2: Anions in Water by CIE-UV\nNOTE: If the general method includes multiple procedures for different analytes, create a Method entry for each subpart.', max_length=450)),
                ('brief_method_summary', models.CharField(help_text='Develop the "Brief method summary" using the Method Summary Section of the method. For example:\nSample, blanks and standards in sealed tubes are heated in an oven or block digestor in the presence of dichromate at 150 C. After two hours, the tubes are removed from the oven or digestor, cooled and measured spectrophotometrically at 600 nm.\nSome details in the summary are fine, but do not make it overly technical. The objective of the summary is to give the NEMI user an idea of how the method works and what it will take to run it, not how to run it.', max_length=4000)),
                ('method_official_name', models.CharField(help_text='This is the main heading of the method. For example for D2036: Standard Test Methods for Total Cyanides in Water After Distillation', max_length=250)),
                ('scope_and_application', models.CharField(blank=True, help_text='The "Scope and Application" field describes the (a) what is measured, and (b) under which conditions (e.g., matrices) the method can be used. For example:\nThis method covers the determination of acid semi-volatile compounds in surface waters, domestic and industrial wastes.', max_length=2000)),
                ('dl_note', models.CharField(blank=True, help_text='The "DL note" describes the conditions under which the detection (or quantitation) limits were determined. For example, were the detection limits determined in reagent water? What conditions were used? How many samples were run? Is their a detailed reference to the detection limit study that was performed? Examples:\nThe EDLs are estimated 3-sigma instrumental detection limits that were described in "EPA Method Study 27, Method 200.7 Trace Metals by ICP" [November 1983] (Available from National Technical Information Service as PB 85-248-656).\n(1) The values given are the minimum level at which the entire GC/MS system must give recognizable mass spectra (background corrected) and acceptable calibration points. (2) The values given refer to one of three techniques for each compound: internal standard quantification, labeled compound quantification, and isotope dilution quantification. Consult Table 3 of the method for information on specific compounds.\nMDLs were determined using the standard deviation of replicate analyses of an analyte-fortified reagent water sample multiplied by the t-value for (# of samples - 1) degrees of freedom atthe 99% confidence level. Detailed instructions for how MDLs are determined are found at 40 CFR part 136, Appendix B.', max_length=2000, verbose_name='DL note')),
                ('applicable_conc_range', models.CharField(blank=True, help_text='The "Applicable concentration range" field describes the effective range of the method (e.g., 0.02 - 1mg/L, > 0.037 Bq/L). Remember to (a) include units, and (b) include a range (e.g., if a radiochem method - with a detection limit (DL) but no effective upper end of the range - the range should be " > DL").\nNOTE: For multi-analyte methods, give a general range of applicability, noting an large deviations (e.g., all analytes are measured in the ug/L range except two, note the two in the different range).', max_length=300)),
                ('interferences', models.CharField(blank=True, help_text='This field presents the potential interferences, along with remedies. For example:\n(A) Glassware contamination: Thoroughly clean glassware, including baking or solvent rinse.\n(B) Reagent contamination: Use high purity reagents.\n(C) Contamination from sample carryover: Rinsing apparatus with hexane and purging equipment between analyses can minimize contamination.\n(D) Extracted interferences: Interference from extracted non-target compounds, with retention times similar to target compounds, can be reduced by cleaning the extract or using confirmation analysis.\n(E) Variable solvents: Use the same solvent for each analysis.\n(F) Endrin degradation: The splitless injector may cause endrin degradation. Endrin can break down by reacting with the active sites on the port sleeve.\n(G) PCBs loss to glass surfaces: Rinse glass and minimize sample contact with glass to prevent adsorption loss of PCBs.\n(H) Oxidation of target compounds: Oxidation of compounds (specifically easily-oxidized aldrin, hexachlorocyclopentadiene, and methoxychlor) can be prevented by adding sodium thiosulfate at collection.\n(I) Phthalate interference: An unknown interference (possibly dibutyl phthalate) appears in heptachlors retention window.', max_length=3000)),
                ('precision_descriptor_notes', models.CharField(blank=True, help_text='The "Precision Descriptor Notes" describe how precision and accuracy data were determined (including references to the number of labs used, types of matrices, number of samples, citation to report, etc.). For example:\nSummarized data results are based on quantification by isotope dilution. Precision and accuracy data was obtained from "Interlaboratory Validation of U.S. Environmental Protection Agency Method 1625A" (July 1984). Study data was collected for samples analyzed at 11-13 laboratories, depending on compounds. Approximately twenty-three percent of laboratories could not quantify or detect compounds by isotope dilution, so these laboratories were excluded from method summaries (the need for these exclusions was primarily based on lack of experience with the method at the time of the 1984 study).\nNote: See Analyte Entry Form for information on how to select precision and accuracy data from the method.\nIF a method contains precision descriptor notes that vary by analyte, provide a general summary of the notes here that is applicable to all analytes in the method. If necessary, direct users to the full method for additional analyte-specific information.', max_length=3000)),
                ('qc_requirements', models.CharField(blank=True, max_length=2000, verbose_name='QC requirements')),
                ('sample_handling', models.CharField(blank=True, max_length=3000)),
                ('max_holding_time', models.CharField(blank=True, max_length=300)),
                ('sample_prep_methods', models.CharField(blank=True, max_length=100)),
                ('link_to_full_method', models.URLField(blank=True, max_length=240, verbose_name='Private Vendor URL (Do not enter URL for public methods)')),
                ('regs_only', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', help_text='If you are reviewing this method, select your username from the list.', max_length=1, verbose_name='regulation only method?')),
                ('reviewer_name', models.CharField(blank=True, max_length=100, verbose_name='If you are reviewing this method, select your username from the list.')),
                ('rapidity', models.CharField(blank=True, max_length=30)),
                ('screening', models.CharField(blank=True, choices=[('Yes', 'Yes'), ('No', 'No'), ('Possibly', 'Possibly')], max_length=8)),
                ('cbr_only', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', max_length=1, verbose_name='CBR only?')),
                ('collected_sample_amt_ml', models.CharField(blank=True, max_length=10, verbose_name='collected sample amount (mL)')),
                ('collected_sample_amt_g', models.CharField(blank=True, max_length=10, verbose_name='collected sample amount (g)')),
                ('liquid_sample_flag', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], max_length=1, null=True)),
                ('analysis_amt_ml', models.CharField(blank=True, help_text='The quantity of sample material that is selected to be treated and prepared for instrumental analysis. It is not the quantity of sample material that is left after sample treatment/preparation.', max_length=10, verbose_name='analysis amount mL')),
                ('analysis_amt_g', models.CharField(blank=True, help_text='The quantity of sample material that is selected to be treated and prepared for instrumental analysis. It is not the quantity of sample material that is left after sample treatment/preparation. If the analytical sample amount is given in mL, this is converted to grams, with the assumed density of 1 for water-based samples.', max_length=10, verbose_name='analysis amount G')),
                ('ph_of_analytical_sample', models.CharField(blank=True, help_text='The pH of the sample when analyzed.', max_length=10, verbose_name='pH of analytical sample')),
                ('calc_waste_amt', models.DecimalField(blank=True, decimal_places=2, help_text='The sum of the amounts (in g) of the analytical sample and all chemicals used to treat the analytical sample.', max_digits=7, null=True, verbose_name='calculated waste amount (g)')),
                ('quality_review_id', models.CharField(blank=True, max_length=100, verbose_name='QA reviewer ID')),
                ('pbt', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text='PBT: A chemical used in the method is listed as "persistent, bioaccumulative, and toxic (PBT)", as defined by the EPA\'s Toxic Release Inventory. \nEmergency Planning and Community Right-to-Know Act; Section 313; Toxic Release Inventory (TRI), the most recent chemical list available in 2006 is for the reporting year 2004, (available on the internet at http://www.epa.gov/tri/chemical/). If this method uses a chemical considered to be PBT by the above definition, select \'Y\'.', max_length=1, verbose_name='Does this method use a chemical considered to be PBT?')),
                ('toxic', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the method uses a chemical listed on EPA's Toxic Release Inventory (TRI) or RCRA's D, F, P, or U lists it fails the greenness test for toxics, so the user should select 'Y'.", max_length=1, verbose_name="Does the method use a chemical listed on EPA's\nToxic Release Inventory (TRI) or RCRA's D, F, P, or U lists?")),
                ('corrosive', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the pH is less than 2 or greater than 12 the method fails the greenness test for corrosivity, so the user should select 'Y'.", max_length=1, verbose_name='Is the final pH of the sample less than 2 or greater than 12 (Corrosive)?')),
                ('waste', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the waste from the method is greater than 50 grams, it fails the greenness test for waste, and the user should select 'Y'.", max_length=1, verbose_name='Is the waste from the method is greater than 50 grams?')),
                ('assumptions_comments', models.CharField(blank=True, max_length=2000, verbose_name='assumptions/comments')),
                ('matrix', models.CharField(blank=True, choices=[('Freshwater', 'Freshwater'), ('Saltwater', 'Saltwater'), ('Both', 'Both')], max_length=12)),
                ('technique', models.CharField(blank=True, choices=[('Test Procedure', 'Test Procedure'), ('Sampling Procedure', 'Sampling Procedure')], max_length=50)),
                ('etv_link', models.CharField(blank=True, max_length=120)),
                ('sam_complexity', models.CharField(blank=True, choices=[('Low', 'Low'), ('Medium', 'Medium'), ('High', 'High')], max_length=10)),
                ('level_of_training', models.CharField(blank=True, choices=[('Basic', 'Basic'), ('Intermediate', 'Intermediate'), ('Advanced', 'Advanced')], max_length=20)),
                ('media_emphasized_note', models.CharField(blank=True, max_length=50)),
                ('media_subcategory', models.CharField(blank=True, max_length=150)),
                ('notes', models.CharField(blank=True, max_length=4000)),
                ('method_id', models.IntegerField(primary_key=True, serialize=False)),
                ('date_loaded', models.DateField(auto_now_add=True)),
                ('conc_range_units', models.ForeignKey(blank=True, db_column='conc_range_units', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.DlUnitsDom', verbose_name='applicable concentration range')),
                ('dl_type', models.ForeignKey(blank=True, help_text='The "Detection limit type" describes the kind of detection (or quantitation) limit information that is found in the method (e.g., MDL, LOQ).\nNote: If separate detection and quantitation limits are provided, use detection limits.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.DlRef', verbose_name='detection limit type')),
                ('instrumentation', models.ForeignKey(help_text='The "Instrument" describes the instrumention used in the method. Choose the appropriate instrumentation from the list of values.\nNOTE: Only one value can be chosen for each method. If your method contains performance information for 2 or more instruments (e.g., GC-ECD and GC-MS), you make separate methods for each instrument, noting the instrument using "( )" after the method number (e.g. 502.2 (GC-PID) and 502.2 (GC-ELCD)).', on_delete=django.db.models.deletion.CASCADE, to='common.InstrumentationRef')),
                ('media_name', models.ForeignKey(blank=True, db_column='media_name', help_text='The "Media" describes the basic form of the sample that is analyze (not the specific matrix-type such as drinking or ground water). Choose the appropriate media (e.g., AIR, WATER) from the list of values.\nSpecific information (e.g., the method is used for "drinking water and groundwater" analyses) should be provided in the "Scope and Application" section.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MediaNameDOM')),
            ],
            options={
                'verbose_name': '#3 published method',
                'db_table': 'method',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='MethodAnalyteVW',
            fields=[
                ('sample_handling', models.CharField(blank=True, max_length=3000)),
                ('max_holding_time', models.CharField(blank=True, max_length=300)),
                ('sample_prep_methods', models.CharField(blank=True, max_length=100)),
                ('relative_cost_id', models.IntegerField(null=True)),
                ('method_source', models.CharField(max_length=20)),
                ('method_source_name', models.CharField(max_length=150)),
                ('method_source_url', models.CharField(blank=True, max_length=200)),
                ('method_subcategory_id', models.IntegerField()),
                ('method_category', models.CharField(max_length=50)),
                ('method_subcategory', models.CharField(max_length=40)),
                ('dl_type', models.CharField(max_length=11)),
                ('dl_type_description', models.CharField(max_length=50)),
                ('source_citation_name', models.CharField(blank=True, max_length=450)),
                ('source_citation', models.CharField(max_length=30)),
                ('source_citation_information', models.CharField(blank=True, max_length=1500)),
                ('relative_cost_symbol', models.CharField(blank=True, max_length=7)),
                ('relative_cost', models.CharField(blank=True, max_length=40)),
                ('matrix', models.CharField(blank=True, max_length=12)),
                ('dl_units', models.CharField(max_length=20)),
                ('dl_value', models.DecimalField(decimal_places=6, max_digits=21, null=True)),
                ('sub_dl_value', models.CharField(blank=True, max_length=40)),
                ('analyte_method_id', models.IntegerField(primary_key=True, serialize=False)),
                ('analyte_id', models.IntegerField()),
                ('accuracy', models.DecimalField(decimal_places=6, max_digits=21, null=True)),
                ('sub_accuracy', models.CharField(blank=True, max_length=40)),
                ('accuracy_order', models.IntegerField(null=True)),
                ('accuracy_units', models.CharField(blank=True, max_length=40)),
                ('precision', models.DecimalField(decimal_places=6, max_digits=21, null=True)),
                ('sub_precision', models.CharField(blank=True, max_length=40)),
                ('precision_units', models.CharField(blank=True, max_length=30)),
                ('prec_acc_conc_used', models.DecimalField(decimal_places=6, max_digits=21, null=True)),
                ('false_positive_value', models.IntegerField(null=True)),
                ('false_negative_value', models.IntegerField(null=True)),
                ('analyte_code', models.CharField(blank=True, max_length=20)),
                ('analyte_name', models.CharField(blank=True, max_length=240)),
                ('preferred', models.IntegerField(null=True)),
                ('analyte_cbr', models.CharField(blank=True, max_length=1)),
                ('dl_units_description', models.CharField(blank=True, max_length=60)),
                ('precision_units_description', models.CharField(blank=True, max_length=100)),
                ('accuracy_units_description', models.CharField(blank=True, max_length=50)),
                ('method_id', models.IntegerField(null=True)),
                ('source_method_identifier', models.CharField(max_length=30)),
                ('method_descriptive_name', models.CharField(max_length=250)),
                ('method_official_name', models.CharField(max_length=250)),
                ('method_source_id', models.IntegerField()),
                ('source_citation_id', models.IntegerField()),
                ('brief_method_summary', models.CharField(max_length=4000)),
                ('scope_and_application', models.CharField(blank=True, max_length=2000)),
                ('media_name', models.CharField(max_length=30)),
                ('dl_type_id', models.IntegerField(null=True)),
                ('dl_note', models.CharField(blank=True, max_length=2000)),
                ('applicable_conc_range', models.CharField(blank=True, max_length=300)),
                ('conc_range_units', models.CharField(blank=True, max_length=20)),
                ('interferences', models.CharField(blank=True, max_length=3000)),
                ('cbr_only', models.CharField(blank=True, max_length=1)),
                ('qc_requirements', models.CharField(blank=True, max_length=2000)),
                ('instrumentation_id', models.IntegerField()),
                ('instrumentation', models.CharField(max_length=20)),
                ('instrumentation_description', models.CharField(max_length=200)),
                ('precision_descriptor_notes', models.CharField(blank=True, max_length=3000)),
                ('link_to_full_method', models.CharField(blank=True, max_length=240)),
            ],
            options={
                'db_table': 'method_analyte_vw',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='MethodOnline',
            fields=[
                ('insert_date', models.DateField(blank=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50)),
                ('last_update_date', models.DateField(blank=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, max_length=50)),
                ('approved', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', max_length=1)),
                ('approved_date', models.DateField(blank=True, null=True)),
                ('source_method_identifier', models.CharField(help_text='The method number / identifier can be numerical (e.g., 375.4), numerical w/text (e.g., 4500-SO4 C) or all text (e.g., Simplate). NOTE: If your method number ends in a "0" (e.g., 300.0), please contact the NEMI manager (entries ending in "0" are automatically truncated in Excel, and must be fixed by the NEMI manager).\nWhatever the format, you must choose a unique method number for your method. Also, keep things specific; do not use "Not Applicable," "Color Method" or something of that nature. If your method does not have a unique identifier, you must create one -- consider using a document number (e.g., EPA-XX-X-XXXX), product number, etc..\nIF a method has a published method number THEN include it ELSE create one', max_length=30, unique=True, verbose_name='method number/identifier')),
                ('method_descriptive_name', models.CharField(blank=True, help_text='This field is designed to provide the user with a quick identification of a method, so include the analyte (ex: "nitrate") or group of analytes (ex; "nutrients"), the matrix (ex: "in water"), and instrumentation (ex: "using colorimetry"):\nEx. 1: Nitrate in Water by Colorimetry\nEx. 2: Anions in Water by CIE-UV\nNOTE: If the general method includes multiple procedures for different analytes, create a Method entry for each subpart.', max_length=450)),
                ('brief_method_summary', models.CharField(help_text='Develop the "Brief method summary" using the Method Summary Section of the method. For example:\nSample, blanks and standards in sealed tubes are heated in an oven or block digestor in the presence of dichromate at 150 C. After two hours, the tubes are removed from the oven or digestor, cooled and measured spectrophotometrically at 600 nm.\nSome details in the summary are fine, but do not make it overly technical. The objective of the summary is to give the NEMI user an idea of how the method works and what it will take to run it, not how to run it.', max_length=4000)),
                ('method_official_name', models.CharField(help_text='This is the main heading of the method. For example for D2036: Standard Test Methods for Total Cyanides in Water After Distillation', max_length=250)),
                ('scope_and_application', models.CharField(blank=True, help_text='The "Scope and Application" field describes the (a) what is measured, and (b) under which conditions (e.g., matrices) the method can be used. For example:\nThis method covers the determination of acid semi-volatile compounds in surface waters, domestic and industrial wastes.', max_length=2000)),
                ('dl_note', models.CharField(blank=True, help_text='The "DL note" describes the conditions under which the detection (or quantitation) limits were determined. For example, were the detection limits determined in reagent water? What conditions were used? How many samples were run? Is their a detailed reference to the detection limit study that was performed? Examples:\nThe EDLs are estimated 3-sigma instrumental detection limits that were described in "EPA Method Study 27, Method 200.7 Trace Metals by ICP" [November 1983] (Available from National Technical Information Service as PB 85-248-656).\n(1) The values given are the minimum level at which the entire GC/MS system must give recognizable mass spectra (background corrected) and acceptable calibration points. (2) The values given refer to one of three techniques for each compound: internal standard quantification, labeled compound quantification, and isotope dilution quantification. Consult Table 3 of the method for information on specific compounds.\nMDLs were determined using the standard deviation of replicate analyses of an analyte-fortified reagent water sample multiplied by the t-value for (# of samples - 1) degrees of freedom atthe 99% confidence level. Detailed instructions for how MDLs are determined are found at 40 CFR part 136, Appendix B.', max_length=2000, verbose_name='DL note')),
                ('applicable_conc_range', models.CharField(blank=True, help_text='The "Applicable concentration range" field describes the effective range of the method (e.g., 0.02 - 1mg/L, > 0.037 Bq/L). Remember to (a) include units, and (b) include a range (e.g., if a radiochem method - with a detection limit (DL) but no effective upper end of the range - the range should be " > DL").\nNOTE: For multi-analyte methods, give a general range of applicability, noting an large deviations (e.g., all analytes are measured in the ug/L range except two, note the two in the different range).', max_length=300)),
                ('interferences', models.CharField(blank=True, help_text='This field presents the potential interferences, along with remedies. For example:\n(A) Glassware contamination: Thoroughly clean glassware, including baking or solvent rinse.\n(B) Reagent contamination: Use high purity reagents.\n(C) Contamination from sample carryover: Rinsing apparatus with hexane and purging equipment between analyses can minimize contamination.\n(D) Extracted interferences: Interference from extracted non-target compounds, with retention times similar to target compounds, can be reduced by cleaning the extract or using confirmation analysis.\n(E) Variable solvents: Use the same solvent for each analysis.\n(F) Endrin degradation: The splitless injector may cause endrin degradation. Endrin can break down by reacting with the active sites on the port sleeve.\n(G) PCBs loss to glass surfaces: Rinse glass and minimize sample contact with glass to prevent adsorption loss of PCBs.\n(H) Oxidation of target compounds: Oxidation of compounds (specifically easily-oxidized aldrin, hexachlorocyclopentadiene, and methoxychlor) can be prevented by adding sodium thiosulfate at collection.\n(I) Phthalate interference: An unknown interference (possibly dibutyl phthalate) appears in heptachlors retention window.', max_length=3000)),
                ('precision_descriptor_notes', models.CharField(blank=True, help_text='The "Precision Descriptor Notes" describe how precision and accuracy data were determined (including references to the number of labs used, types of matrices, number of samples, citation to report, etc.). For example:\nSummarized data results are based on quantification by isotope dilution. Precision and accuracy data was obtained from "Interlaboratory Validation of U.S. Environmental Protection Agency Method 1625A" (July 1984). Study data was collected for samples analyzed at 11-13 laboratories, depending on compounds. Approximately twenty-three percent of laboratories could not quantify or detect compounds by isotope dilution, so these laboratories were excluded from method summaries (the need for these exclusions was primarily based on lack of experience with the method at the time of the 1984 study).\nNote: See Analyte Entry Form for information on how to select precision and accuracy data from the method.\nIF a method contains precision descriptor notes that vary by analyte, provide a general summary of the notes here that is applicable to all analytes in the method. If necessary, direct users to the full method for additional analyte-specific information.', max_length=3000)),
                ('qc_requirements', models.CharField(blank=True, max_length=2000, verbose_name='QC requirements')),
                ('sample_handling', models.CharField(blank=True, max_length=3000)),
                ('max_holding_time', models.CharField(blank=True, max_length=300)),
                ('sample_prep_methods', models.CharField(blank=True, max_length=100)),
                ('link_to_full_method', models.URLField(blank=True, max_length=240, verbose_name='Private Vendor URL (Do not enter URL for public methods)')),
                ('regs_only', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', help_text='If you are reviewing this method, select your username from the list.', max_length=1, verbose_name='regulation only method?')),
                ('reviewer_name', models.CharField(blank=True, max_length=100, verbose_name='If you are reviewing this method, select your username from the list.')),
                ('rapidity', models.CharField(blank=True, max_length=30)),
                ('screening', models.CharField(blank=True, choices=[('Yes', 'Yes'), ('No', 'No'), ('Possibly', 'Possibly')], max_length=8)),
                ('cbr_only', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', max_length=1, verbose_name='CBR only?')),
                ('collected_sample_amt_ml', models.CharField(blank=True, max_length=10, verbose_name='collected sample amount (mL)')),
                ('collected_sample_amt_g', models.CharField(blank=True, max_length=10, verbose_name='collected sample amount (g)')),
                ('liquid_sample_flag', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], max_length=1, null=True)),
                ('analysis_amt_ml', models.CharField(blank=True, help_text='The quantity of sample material that is selected to be treated and prepared for instrumental analysis. It is not the quantity of sample material that is left after sample treatment/preparation.', max_length=10, verbose_name='analysis amount mL')),
                ('analysis_amt_g', models.CharField(blank=True, help_text='The quantity of sample material that is selected to be treated and prepared for instrumental analysis. It is not the quantity of sample material that is left after sample treatment/preparation. If the analytical sample amount is given in mL, this is converted to grams, with the assumed density of 1 for water-based samples.', max_length=10, verbose_name='analysis amount G')),
                ('ph_of_analytical_sample', models.CharField(blank=True, help_text='The pH of the sample when analyzed.', max_length=10, verbose_name='pH of analytical sample')),
                ('calc_waste_amt', models.DecimalField(blank=True, decimal_places=2, help_text='The sum of the amounts (in g) of the analytical sample and all chemicals used to treat the analytical sample.', max_digits=7, null=True, verbose_name='calculated waste amount (g)')),
                ('quality_review_id', models.CharField(blank=True, max_length=100, verbose_name='QA reviewer ID')),
                ('pbt', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text='PBT: A chemical used in the method is listed as "persistent, bioaccumulative, and toxic (PBT)", as defined by the EPA\'s Toxic Release Inventory. \nEmergency Planning and Community Right-to-Know Act; Section 313; Toxic Release Inventory (TRI), the most recent chemical list available in 2006 is for the reporting year 2004, (available on the internet at http://www.epa.gov/tri/chemical/). If this method uses a chemical considered to be PBT by the above definition, select \'Y\'.', max_length=1, verbose_name='Does this method use a chemical considered to be PBT?')),
                ('toxic', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the method uses a chemical listed on EPA's Toxic Release Inventory (TRI) or RCRA's D, F, P, or U lists it fails the greenness test for toxics, so the user should select 'Y'.", max_length=1, verbose_name="Does the method use a chemical listed on EPA's\nToxic Release Inventory (TRI) or RCRA's D, F, P, or U lists?")),
                ('corrosive', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the pH is less than 2 or greater than 12 the method fails the greenness test for corrosivity, so the user should select 'Y'.", max_length=1, verbose_name='Is the final pH of the sample less than 2 or greater than 12 (Corrosive)?')),
                ('waste', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the waste from the method is greater than 50 grams, it fails the greenness test for waste, and the user should select 'Y'.", max_length=1, verbose_name='Is the waste from the method is greater than 50 grams?')),
                ('assumptions_comments', models.CharField(blank=True, max_length=2000, verbose_name='assumptions/comments')),
                ('matrix', models.CharField(blank=True, choices=[('Freshwater', 'Freshwater'), ('Saltwater', 'Saltwater'), ('Both', 'Both')], max_length=12)),
                ('technique', models.CharField(blank=True, choices=[('Test Procedure', 'Test Procedure'), ('Sampling Procedure', 'Sampling Procedure')], max_length=50)),
                ('etv_link', models.CharField(blank=True, max_length=120)),
                ('sam_complexity', models.CharField(blank=True, choices=[('Low', 'Low'), ('Medium', 'Medium'), ('High', 'High')], max_length=10)),
                ('level_of_training', models.CharField(blank=True, choices=[('Basic', 'Basic'), ('Intermediate', 'Intermediate'), ('Advanced', 'Advanced')], max_length=20)),
                ('media_emphasized_note', models.CharField(blank=True, max_length=50)),
                ('media_subcategory', models.CharField(blank=True, max_length=150)),
                ('notes', models.CharField(blank=True, max_length=4000)),
                ('method_id', models.AutoField(primary_key=True, serialize=False)),
                ('no_analyte_flag', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text='Select if this method will not have analytes associated with it.', max_length=4, null=True, verbose_name='no analytes')),
                ('comments', models.CharField(blank=True, help_text='This field is only to be used to communicate method entry status to the NEMI data review team, for example, if you will be entering 10 methods, you can report that in this field, "Method 1 of 10", "Method 2 of 10", etc. It would be particularly helpful to notify the team when you have entered the last of your batch of methods using this field so that they know to start reviewing the methods.', max_length=2000)),
                ('ready_for_review', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', max_length=1)),
                ('insert_person_name2', models.CharField(blank=True, max_length=100)),
                ('delete_after_load', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='Y', max_length=1)),
                ('conc_range_units', models.ForeignKey(blank=True, db_column='conc_range_units', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.DlUnitsDom', verbose_name='applicable concentration range')),
                ('dl_type', models.ForeignKey(blank=True, help_text='The "Detection limit type" describes the kind of detection (or quantitation) limit information that is found in the method (e.g., MDL, LOQ).\nNote: If separate detection and quantitation limits are provided, use detection limits.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.DlRef', verbose_name='detection limit type')),
                ('instrumentation', models.ForeignKey(help_text='The "Instrument" describes the instrumention used in the method. Choose the appropriate instrumentation from the list of values.\nNOTE: Only one value can be chosen for each method. If your method contains performance information for 2 or more instruments (e.g., GC-ECD and GC-MS), you make separate methods for each instrument, noting the instrument using "( )" after the method number (e.g. 502.2 (GC-PID) and 502.2 (GC-ELCD)).', on_delete=django.db.models.deletion.CASCADE, to='common.InstrumentationRef')),
                ('media_name', models.ForeignKey(blank=True, db_column='media_name', help_text='The "Media" describes the basic form of the sample that is analyze (not the specific matrix-type such as drinking or ground water). Choose the appropriate media (e.g., AIR, WATER) from the list of values.\nSpecific information (e.g., the method is used for "drinking water and groundwater" analyses) should be provided in the "Scope and Application" section.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MediaNameDOM')),
            ],
            options={
                'verbose_name': '#1 pending method',
                'db_table': 'method_online',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='MethodSourceRef',
            fields=[
                ('method_source_id', models.IntegerField(primary_key=True, serialize=False)),
                ('method_source', models.CharField(max_length=20)),
                ('method_source_url', models.CharField(blank=True, max_length=200)),
                ('method_source_name', models.CharField(max_length=150)),
                ('method_source_contact', models.CharField(blank=True, max_length=450)),
                ('method_source_email', models.CharField(blank=True, max_length=100)),
            ],
            options={
                'db_table': 'method_source_ref',
                'ordering': ['method_source'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='MethodStg',
            fields=[
                ('insert_date', models.DateField(blank=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50)),
                ('last_update_date', models.DateField(blank=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, max_length=50)),
                ('approved', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', max_length=1)),
                ('approved_date', models.DateField(blank=True, null=True)),
                ('source_method_identifier', models.CharField(help_text='The method number / identifier can be numerical (e.g., 375.4), numerical w/text (e.g., 4500-SO4 C) or all text (e.g., Simplate). NOTE: If your method number ends in a "0" (e.g., 300.0), please contact the NEMI manager (entries ending in "0" are automatically truncated in Excel, and must be fixed by the NEMI manager).\nWhatever the format, you must choose a unique method number for your method. Also, keep things specific; do not use "Not Applicable," "Color Method" or something of that nature. If your method does not have a unique identifier, you must create one -- consider using a document number (e.g., EPA-XX-X-XXXX), product number, etc..\nIF a method has a published method number THEN include it ELSE create one', max_length=30, unique=True, verbose_name='method number/identifier')),
                ('method_descriptive_name', models.CharField(blank=True, help_text='This field is designed to provide the user with a quick identification of a method, so include the analyte (ex: "nitrate") or group of analytes (ex; "nutrients"), the matrix (ex: "in water"), and instrumentation (ex: "using colorimetry"):\nEx. 1: Nitrate in Water by Colorimetry\nEx. 2: Anions in Water by CIE-UV\nNOTE: If the general method includes multiple procedures for different analytes, create a Method entry for each subpart.', max_length=450)),
                ('brief_method_summary', models.CharField(help_text='Develop the "Brief method summary" using the Method Summary Section of the method. For example:\nSample, blanks and standards in sealed tubes are heated in an oven or block digestor in the presence of dichromate at 150 C. After two hours, the tubes are removed from the oven or digestor, cooled and measured spectrophotometrically at 600 nm.\nSome details in the summary are fine, but do not make it overly technical. The objective of the summary is to give the NEMI user an idea of how the method works and what it will take to run it, not how to run it.', max_length=4000)),
                ('method_official_name', models.CharField(help_text='This is the main heading of the method. For example for D2036: Standard Test Methods for Total Cyanides in Water After Distillation', max_length=250)),
                ('scope_and_application', models.CharField(blank=True, help_text='The "Scope and Application" field describes the (a) what is measured, and (b) under which conditions (e.g., matrices) the method can be used. For example:\nThis method covers the determination of acid semi-volatile compounds in surface waters, domestic and industrial wastes.', max_length=2000)),
                ('dl_note', models.CharField(blank=True, help_text='The "DL note" describes the conditions under which the detection (or quantitation) limits were determined. For example, were the detection limits determined in reagent water? What conditions were used? How many samples were run? Is their a detailed reference to the detection limit study that was performed? Examples:\nThe EDLs are estimated 3-sigma instrumental detection limits that were described in "EPA Method Study 27, Method 200.7 Trace Metals by ICP" [November 1983] (Available from National Technical Information Service as PB 85-248-656).\n(1) The values given are the minimum level at which the entire GC/MS system must give recognizable mass spectra (background corrected) and acceptable calibration points. (2) The values given refer to one of three techniques for each compound: internal standard quantification, labeled compound quantification, and isotope dilution quantification. Consult Table 3 of the method for information on specific compounds.\nMDLs were determined using the standard deviation of replicate analyses of an analyte-fortified reagent water sample multiplied by the t-value for (# of samples - 1) degrees of freedom atthe 99% confidence level. Detailed instructions for how MDLs are determined are found at 40 CFR part 136, Appendix B.', max_length=2000, verbose_name='DL note')),
                ('applicable_conc_range', models.CharField(blank=True, help_text='The "Applicable concentration range" field describes the effective range of the method (e.g., 0.02 - 1mg/L, > 0.037 Bq/L). Remember to (a) include units, and (b) include a range (e.g., if a radiochem method - with a detection limit (DL) but no effective upper end of the range - the range should be " > DL").\nNOTE: For multi-analyte methods, give a general range of applicability, noting an large deviations (e.g., all analytes are measured in the ug/L range except two, note the two in the different range).', max_length=300)),
                ('interferences', models.CharField(blank=True, help_text='This field presents the potential interferences, along with remedies. For example:\n(A) Glassware contamination: Thoroughly clean glassware, including baking or solvent rinse.\n(B) Reagent contamination: Use high purity reagents.\n(C) Contamination from sample carryover: Rinsing apparatus with hexane and purging equipment between analyses can minimize contamination.\n(D) Extracted interferences: Interference from extracted non-target compounds, with retention times similar to target compounds, can be reduced by cleaning the extract or using confirmation analysis.\n(E) Variable solvents: Use the same solvent for each analysis.\n(F) Endrin degradation: The splitless injector may cause endrin degradation. Endrin can break down by reacting with the active sites on the port sleeve.\n(G) PCBs loss to glass surfaces: Rinse glass and minimize sample contact with glass to prevent adsorption loss of PCBs.\n(H) Oxidation of target compounds: Oxidation of compounds (specifically easily-oxidized aldrin, hexachlorocyclopentadiene, and methoxychlor) can be prevented by adding sodium thiosulfate at collection.\n(I) Phthalate interference: An unknown interference (possibly dibutyl phthalate) appears in heptachlors retention window.', max_length=3000)),
                ('precision_descriptor_notes', models.CharField(blank=True, help_text='The "Precision Descriptor Notes" describe how precision and accuracy data were determined (including references to the number of labs used, types of matrices, number of samples, citation to report, etc.). For example:\nSummarized data results are based on quantification by isotope dilution. Precision and accuracy data was obtained from "Interlaboratory Validation of U.S. Environmental Protection Agency Method 1625A" (July 1984). Study data was collected for samples analyzed at 11-13 laboratories, depending on compounds. Approximately twenty-three percent of laboratories could not quantify or detect compounds by isotope dilution, so these laboratories were excluded from method summaries (the need for these exclusions was primarily based on lack of experience with the method at the time of the 1984 study).\nNote: See Analyte Entry Form for information on how to select precision and accuracy data from the method.\nIF a method contains precision descriptor notes that vary by analyte, provide a general summary of the notes here that is applicable to all analytes in the method. If necessary, direct users to the full method for additional analyte-specific information.', max_length=3000)),
                ('qc_requirements', models.CharField(blank=True, max_length=2000, verbose_name='QC requirements')),
                ('sample_handling', models.CharField(blank=True, max_length=3000)),
                ('max_holding_time', models.CharField(blank=True, max_length=300)),
                ('sample_prep_methods', models.CharField(blank=True, max_length=100)),
                ('link_to_full_method', models.URLField(blank=True, max_length=240, verbose_name='Private Vendor URL (Do not enter URL for public methods)')),
                ('regs_only', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', help_text='If you are reviewing this method, select your username from the list.', max_length=1, verbose_name='regulation only method?')),
                ('reviewer_name', models.CharField(blank=True, max_length=100, verbose_name='If you are reviewing this method, select your username from the list.')),
                ('rapidity', models.CharField(blank=True, max_length=30)),
                ('screening', models.CharField(blank=True, choices=[('Yes', 'Yes'), ('No', 'No'), ('Possibly', 'Possibly')], max_length=8)),
                ('cbr_only', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', max_length=1, verbose_name='CBR only?')),
                ('collected_sample_amt_ml', models.CharField(blank=True, max_length=10, verbose_name='collected sample amount (mL)')),
                ('collected_sample_amt_g', models.CharField(blank=True, max_length=10, verbose_name='collected sample amount (g)')),
                ('liquid_sample_flag', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], max_length=1, null=True)),
                ('analysis_amt_ml', models.CharField(blank=True, help_text='The quantity of sample material that is selected to be treated and prepared for instrumental analysis. It is not the quantity of sample material that is left after sample treatment/preparation.', max_length=10, verbose_name='analysis amount mL')),
                ('analysis_amt_g', models.CharField(blank=True, help_text='The quantity of sample material that is selected to be treated and prepared for instrumental analysis. It is not the quantity of sample material that is left after sample treatment/preparation. If the analytical sample amount is given in mL, this is converted to grams, with the assumed density of 1 for water-based samples.', max_length=10, verbose_name='analysis amount G')),
                ('ph_of_analytical_sample', models.CharField(blank=True, help_text='The pH of the sample when analyzed.', max_length=10, verbose_name='pH of analytical sample')),
                ('calc_waste_amt', models.DecimalField(blank=True, decimal_places=2, help_text='The sum of the amounts (in g) of the analytical sample and all chemicals used to treat the analytical sample.', max_digits=7, null=True, verbose_name='calculated waste amount (g)')),
                ('quality_review_id', models.CharField(blank=True, max_length=100, verbose_name='QA reviewer ID')),
                ('pbt', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text='PBT: A chemical used in the method is listed as "persistent, bioaccumulative, and toxic (PBT)", as defined by the EPA\'s Toxic Release Inventory. \nEmergency Planning and Community Right-to-Know Act; Section 313; Toxic Release Inventory (TRI), the most recent chemical list available in 2006 is for the reporting year 2004, (available on the internet at http://www.epa.gov/tri/chemical/). If this method uses a chemical considered to be PBT by the above definition, select \'Y\'.', max_length=1, verbose_name='Does this method use a chemical considered to be PBT?')),
                ('toxic', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the method uses a chemical listed on EPA's Toxic Release Inventory (TRI) or RCRA's D, F, P, or U lists it fails the greenness test for toxics, so the user should select 'Y'.", max_length=1, verbose_name="Does the method use a chemical listed on EPA's\nToxic Release Inventory (TRI) or RCRA's D, F, P, or U lists?")),
                ('corrosive', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the pH is less than 2 or greater than 12 the method fails the greenness test for corrosivity, so the user should select 'Y'.", max_length=1, verbose_name='Is the final pH of the sample less than 2 or greater than 12 (Corrosive)?')),
                ('waste', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text="If the waste from the method is greater than 50 grams, it fails the greenness test for waste, and the user should select 'Y'.", max_length=1, verbose_name='Is the waste from the method is greater than 50 grams?')),
                ('assumptions_comments', models.CharField(blank=True, max_length=2000, verbose_name='assumptions/comments')),
                ('matrix', models.CharField(blank=True, choices=[('Freshwater', 'Freshwater'), ('Saltwater', 'Saltwater'), ('Both', 'Both')], max_length=12)),
                ('technique', models.CharField(blank=True, choices=[('Test Procedure', 'Test Procedure'), ('Sampling Procedure', 'Sampling Procedure')], max_length=50)),
                ('etv_link', models.CharField(blank=True, max_length=120)),
                ('sam_complexity', models.CharField(blank=True, choices=[('Low', 'Low'), ('Medium', 'Medium'), ('High', 'High')], max_length=10)),
                ('level_of_training', models.CharField(blank=True, choices=[('Basic', 'Basic'), ('Intermediate', 'Intermediate'), ('Advanced', 'Advanced')], max_length=20)),
                ('media_emphasized_note', models.CharField(blank=True, max_length=50)),
                ('media_subcategory', models.CharField(blank=True, max_length=150)),
                ('notes', models.CharField(blank=True, max_length=4000)),
                ('method_id', models.AutoField(primary_key=True, serialize=False)),
                ('no_analyte_flag', models.CharField(blank=True, choices=[('N', 'No'), ('Y', 'Yes')], help_text='Select if this method will not have analytes associated with it.', max_length=4, null=True, verbose_name='no analytes')),
                ('comments', models.CharField(blank=True, help_text='This field is only to be used to communicate method entry status to the NEMI data review team, for example, if you will be entering 10 methods, you can report that in this field, "Method 1 of 10", "Method 2 of 10", etc. It would be particularly helpful to notify the team when you have entered the last of your batch of methods using this field so that they know to start reviewing the methods.', max_length=2000)),
                ('ready_for_review', models.CharField(choices=[('N', 'No'), ('Y', 'Yes')], default='N', max_length=1)),
                ('date_loaded', models.DateField()),
                ('conc_range_units', models.ForeignKey(blank=True, db_column='conc_range_units', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.DlUnitsDom', verbose_name='applicable concentration range')),
                ('dl_type', models.ForeignKey(blank=True, help_text='The "Detection limit type" describes the kind of detection (or quantitation) limit information that is found in the method (e.g., MDL, LOQ).\nNote: If separate detection and quantitation limits are provided, use detection limits.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.DlRef', verbose_name='detection limit type')),
                ('instrumentation', models.ForeignKey(help_text='The "Instrument" describes the instrumention used in the method. Choose the appropriate instrumentation from the list of values.\nNOTE: Only one value can be chosen for each method. If your method contains performance information for 2 or more instruments (e.g., GC-ECD and GC-MS), you make separate methods for each instrument, noting the instrument using "( )" after the method number (e.g. 502.2 (GC-PID) and 502.2 (GC-ELCD)).', on_delete=django.db.models.deletion.CASCADE, to='common.InstrumentationRef')),
                ('media_name', models.ForeignKey(blank=True, db_column='media_name', help_text='The "Media" describes the basic form of the sample that is analyze (not the specific matrix-type such as drinking or ground water). Choose the appropriate media (e.g., AIR, WATER) from the list of values.\nSpecific information (e.g., the method is used for "drinking water and groundwater" analyses) should be provided in the "Scope and Application" section.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MediaNameDOM')),
                ('method_source', models.ForeignKey(blank=True, help_text='The "Method source" is the organization that publishes a method.\nIF a method has a publication source THEN include it ELSE do not include method in database', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MethodSourceRef')),
            ],
            options={
                'verbose_name': '#2 in-review method',
                'db_table': 'method_stg',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='MethodSubcategoryRef',
            fields=[
                ('method_subcategory_id', models.IntegerField(primary_key=True, serialize=False)),
                ('method_category', models.CharField(max_length=50)),
                ('method_subcategory', models.CharField(max_length=40)),
            ],
            options={
                'db_table': 'method_subcategory_ref',
                'ordering': ('method_subcategory',),
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='MethodTypeRef',
            fields=[
                ('method_type_id', models.IntegerField(primary_key=True, serialize=False)),
                ('method_type_desc', models.CharField(max_length=100)),
            ],
            options={
                'db_table': 'method_type_ref',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='ProtocolMethodOnlineRel',
            fields=[
                ('protocol_method_id', models.AutoField(primary_key=True, serialize=False)),
                ('method', models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, related_name='protocols', to='common.MethodOnline')),
            ],
            options={
                'db_table': 'protocol_method_online_rel',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='ProtocolMethodRel',
            fields=[
                ('protocol_method_id', models.AutoField(primary_key=True, serialize=False)),
                ('method', models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, related_name='protocols', to='common.Method')),
            ],
            options={
                'db_table': 'protocol_method_rel',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='ProtocolMethodStgRel',
            fields=[
                ('protocol_method_id', models.AutoField(primary_key=True, serialize=False)),
                ('method', models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, related_name='protocols', to='common.MethodStg')),
            ],
            options={
                'verbose_name': 'protocol method',
                'db_table': 'protocol_method_stg_rel',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='ProtocolRevisionJoinStg',
            fields=[
                ('revision_id', models.AutoField(primary_key=True, serialize=False)),
                ('revision_flag', models.BooleanField(db_column='revision_flag')),
                ('revision_information', models.CharField(max_length=100)),
                ('insert_date', models.DateField(auto_now_add=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, editable=False, max_length=50, null=True)),
                ('last_update_date', models.DateField(auto_now=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, editable=False, max_length=50, null=True)),
                ('pdf_insert_person', models.CharField(blank=True, max_length=20, null=True)),
                ('pdf_insert_date', models.DateField(blank=True, null=True)),
                ('method_pdf', models.BinaryField(blank=True, null=True)),
                ('mimetype', models.CharField(blank=True, max_length=50, null=True)),
                ('date_loaded', models.DateField(blank=True, null=True)),
                ('method', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='protocol_revisions', to='common.MethodStg')),
            ],
            options={
                'verbose_name': 'staging revision',
                'db_table': 'revision_join_stg',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='PublicationSourceRel',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
            ],
            options={
                'db_table': 'publication_source_rel',
                'ordering': ['source'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='PublicationSourceRelStg',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('source_citation_ref_id', models.IntegerField(db_column='sourcecitationref_id')),
            ],
            options={
                'db_table': 'publication_source_rel_stg',
                'ordering': ['source'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='RelativeCostRef',
            fields=[
                ('relative_cost_id', models.IntegerField(primary_key=True, serialize=False)),
                ('relative_cost_symbol', models.CharField(max_length=7)),
                ('relative_cost', models.CharField(max_length=40)),
                ('cost_effort_key', models.CharField(max_length=10)),
            ],
            options={
                'db_table': 'relative_cost_ref',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='RevisionJoin',
            fields=[
                ('revision_id', models.AutoField(primary_key=True, serialize=False)),
                ('revision_flag', models.BooleanField(db_column='revision_flag')),
                ('revision_information', models.CharField(max_length=100)),
                ('insert_date', models.DateField(auto_now_add=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, editable=False, max_length=50, null=True)),
                ('last_update_date', models.DateField(auto_now=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, editable=False, max_length=50, null=True)),
                ('pdf_insert_person', models.CharField(blank=True, max_length=20, null=True)),
                ('pdf_insert_date', models.DateField(blank=True, null=True)),
                ('method_pdf', models.BinaryField(blank=True, null=True)),
                ('mimetype', models.CharField(blank=True, max_length=50, null=True)),
                ('date_loaded', models.DateField(blank=True, null=True)),
                ('method', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='revisions', to='common.Method')),
            ],
            options={
                'verbose_name': 'revision',
                'db_table': 'revision_join',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='RevisionJoinOnline',
            fields=[
                ('revision_id', models.AutoField(primary_key=True, serialize=False)),
                ('revision_flag', models.BooleanField(db_column='revision_flag')),
                ('revision_information', models.CharField(max_length=100)),
                ('insert_date', models.DateField(auto_now_add=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, editable=False, max_length=50, null=True)),
                ('last_update_date', models.DateField(auto_now=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, editable=False, max_length=50, null=True)),
                ('pdf_insert_person', models.CharField(blank=True, max_length=20, null=True)),
                ('pdf_insert_date', models.DateField(blank=True, null=True)),
                ('method_pdf', models.BinaryField(blank=True, null=True)),
                ('mimetype', models.CharField(blank=True, max_length=50, null=True)),
                ('reviewer_name', models.CharField(blank=True, max_length=100, null=True)),
                ('method', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='revisions', to='common.MethodOnline')),
            ],
            options={
                'verbose_name': 'pending revision',
                'db_table': 'revision_join_online',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='RevisionJoinStg',
            fields=[
                ('revision_id', models.AutoField(primary_key=True, serialize=False)),
                ('revision_flag', models.BooleanField(db_column='revision_flag')),
                ('revision_information', models.CharField(max_length=100)),
                ('insert_date', models.DateField(auto_now_add=True, null=True)),
                ('insert_person_name', models.CharField(blank=True, editable=False, max_length=50, null=True)),
                ('last_update_date', models.DateField(auto_now=True, null=True)),
                ('last_update_person_name', models.CharField(blank=True, editable=False, max_length=50, null=True)),
                ('pdf_insert_person', models.CharField(blank=True, max_length=20, null=True)),
                ('pdf_insert_date', models.DateField(blank=True, null=True)),
                ('method_pdf', models.BinaryField(blank=True, null=True)),
                ('mimetype', models.CharField(blank=True, max_length=50, null=True)),
                ('date_loaded', models.DateField(blank=True, null=True)),
                ('method', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='revisions', to='common.MethodStg')),
            ],
            options={
                'verbose_name': 'staging revision',
                'db_table': 'revision_join_stg',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SourceCitationOnlineRef',
            fields=[
                ('source_citation', models.CharField(max_length=30)),
                ('source_citation_name', models.CharField(max_length=450)),
                ('source_citation_information', models.CharField(blank=True, max_length=1500)),
                ('title', models.CharField(max_length=450)),
                ('author', models.CharField(max_length=450)),
                ('table_of_contents', models.CharField(max_length=1000)),
                ('abstract_summary', models.CharField(max_length=2000)),
                ('link', models.URLField(blank=True, max_length=450)),
                ('publication_year', models.IntegerField(null=True)),
                ('country', models.CharField(blank=True, max_length=100)),
                ('item_type_note', models.CharField(blank=True, max_length=50)),
                ('sponser_type_note', models.CharField(blank=True, max_length=50)),
                ('citation_type', models.CharField(blank=True, max_length=50)),
                ('insert_date', models.DateField(auto_now_add=True)),
                ('update_date', models.DateField(auto_now=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50)),
                ('source_citation_id', models.AutoField(primary_key=True, serialize=False)),
            ],
            options={
                'db_table': 'source_citation_online_ref',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SourceCitationRef',
            fields=[
                ('source_citation', models.CharField(max_length=30)),
                ('source_citation_name', models.CharField(max_length=450)),
                ('source_citation_information', models.CharField(blank=True, max_length=1500)),
                ('title', models.CharField(max_length=450)),
                ('author', models.CharField(max_length=450)),
                ('table_of_contents', models.CharField(max_length=1000)),
                ('abstract_summary', models.CharField(max_length=2000)),
                ('link', models.URLField(blank=True, max_length=450)),
                ('publication_year', models.IntegerField(null=True)),
                ('country', models.CharField(blank=True, max_length=100)),
                ('item_type_note', models.CharField(blank=True, max_length=50)),
                ('sponser_type_note', models.CharField(blank=True, max_length=50)),
                ('citation_type', models.CharField(blank=True, max_length=50)),
                ('insert_date', models.DateField(auto_now_add=True)),
                ('update_date', models.DateField(auto_now=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50)),
                ('source_citation_id', models.IntegerField(primary_key=True, serialize=False)),
            ],
            options={
                'db_table': 'source_citation_ref',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='SourceCitationStgRef',
            fields=[
                ('source_citation', models.CharField(max_length=30)),
                ('source_citation_name', models.CharField(max_length=450)),
                ('source_citation_information', models.CharField(blank=True, max_length=1500)),
                ('title', models.CharField(max_length=450)),
                ('author', models.CharField(max_length=450)),
                ('table_of_contents', models.CharField(max_length=1000)),
                ('abstract_summary', models.CharField(max_length=2000)),
                ('link', models.URLField(blank=True, max_length=450)),
                ('publication_year', models.IntegerField(null=True)),
                ('country', models.CharField(blank=True, max_length=100)),
                ('item_type_note', models.CharField(blank=True, max_length=50)),
                ('sponser_type_note', models.CharField(blank=True, max_length=50)),
                ('citation_type', models.CharField(blank=True, max_length=50)),
                ('insert_date', models.DateField(auto_now_add=True)),
                ('update_date', models.DateField(auto_now=True)),
                ('insert_person_name', models.CharField(blank=True, max_length=50)),
                ('source_citation_id', models.IntegerField(primary_key=True, serialize=False)),
            ],
            options={
                'db_table': 'source_citation_stg_ref',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatAnalysisRel',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
            ],
            options={
                'db_table': 'stat_analysis_rel',
                'ordering': ['analysis_type'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatAnalysisRelStg',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method_id', models.IntegerField()),
            ],
            options={
                'db_table': 'stat_analysis_rel_stg',
                'ordering': ['analysis_type'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatDesignRel',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
            ],
            options={
                'db_table': 'stat_design_rel',
                'ordering': ['design_objective'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatDesignRelStg',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method_id', models.IntegerField()),
            ],
            options={
                'db_table': 'stat_design_rel_stg',
                'ordering': ['design_objective'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatisticalAnalysisType',
            fields=[
                ('stat_analysis_index', models.IntegerField(primary_key=True, serialize=False)),
                ('analysis_type', models.CharField(max_length=100)),
            ],
            options={
                'db_table': 'statistical_analysis_type',
                'ordering': ['analysis_type'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatisticalDesignObjective',
            fields=[
                ('stat_design_index', models.IntegerField(primary_key=True, serialize=False)),
                ('objective', models.CharField(max_length=200)),
            ],
            options={
                'db_table': 'statistical_design_objective',
                'ordering': ['objective'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatisticalItemType',
            fields=[
                ('stat_item_index', models.IntegerField(primary_key=True, serialize=False)),
                ('item', models.CharField(max_length=100)),
            ],
            options={
                'db_table': 'statistical_item_type',
                'ordering': ['item'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatisticalSourceType',
            fields=[
                ('stat_source_index', models.IntegerField(primary_key=True, serialize=False)),
                ('source', models.CharField(max_length=100)),
            ],
            options={
                'db_table': 'statistical_source_type',
                'ordering': ['source'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatisticalTopics',
            fields=[
                ('stat_topic_index', models.IntegerField(primary_key=True, serialize=False)),
                ('stat_special_topic', models.CharField(max_length=200)),
            ],
            options={
                'db_table': 'statistical_topics',
                'ordering': ['stat_special_topic'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatMediaRel',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('media_name', models.ForeignKey(db_column='medianamedom_id', on_delete=django.db.models.deletion.CASCADE, to='common.MediaNameDOM')),
                ('method', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.Method')),
            ],
            options={
                'db_table': 'stat_media_rel',
                'ordering': ['media_name'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatMediaRelStg',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method_id', models.IntegerField()),
                ('media_name', models.ForeignKey(db_column='medianamedom_id', on_delete=django.db.models.deletion.CASCADE, to='common.MediaNameDOM')),
            ],
            options={
                'db_table': 'stat_media_rel_stg',
                'ordering': ['media_name'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatTopicRel',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.Method')),
                ('topic', models.ForeignKey(db_column='statisticaltopics_id', on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalTopics')),
            ],
            options={
                'db_table': 'stat_topic_rel',
                'ordering': ['topic'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='StatTopicRelStg',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('method_id', models.IntegerField()),
                ('topic', models.ForeignKey(db_column='statisticaltopics_id', on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalTopics')),
            ],
            options={
                'db_table': 'stat_topic_rel_stg',
                'ordering': ['topic'],
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='UserRole',
            fields=[
                ('role_name', models.CharField(max_length=400, primary_key=True, serialize=False)),
                ('role_description', models.CharField(blank=True, max_length=400, null=True)),
            ],
            options={
                'db_table': 'user_roles',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='WaterbodyTypeRef',
            fields=[
                ('waterbody_type_id', models.IntegerField(unique=True)),
                ('waterbody_type_desc', models.CharField(max_length=100, primary_key=True, serialize=False, unique=True)),
            ],
            options={
                'db_table': 'waterbody_type_ref',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='WqsaCategoryMap',
            fields=[
                ('wqsa_category_cd', models.IntegerField(primary_key=True, serialize=False)),
                ('wqsa_category', models.CharField(blank=True, max_length=2000, null=True)),
            ],
            options={
                'db_table': 'wqsa_category_map',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='ProtocolSourceCitationStgRef',
            fields=[
            ],
            options={
                'verbose_name': 'protocol source citation',
                'managed': False,
                'proxy': True,
                'indexes': [],
            },
            bases=('reference.sourcecitationstgref',),
        ),
        migrations.AddField(
            model_name='statdesignrelstg',
            name='design_objective',
            field=models.ForeignKey(db_column='statisticaldesignobjective_id', on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalDesignObjective'),
        ),
        migrations.AddField(
            model_name='statdesignrel',
            name='design_objective',
            field=models.ForeignKey(db_column='statisticaldesignobjective_id', on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalDesignObjective'),
        ),
        migrations.AddField(
            model_name='statdesignrel',
            name='method',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.Method'),
        ),
        migrations.AddField(
            model_name='statanalysisrelstg',
            name='analysis_type',
            field=models.ForeignKey(db_column='statisticalanalysistype_id', on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalAnalysisType'),
        ),
        migrations.AddField(
            model_name='statanalysisrel',
            name='analysis_type',
            field=models.ForeignKey(db_column='statisticalanalysistype_id', on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalAnalysisType'),
        ),
        migrations.AddField(
            model_name='statanalysisrel',
            name='method',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.Method'),
        ),
        migrations.AddField(
            model_name='sourcecitationstgref',
            name='item_type',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalItemType'),
        ),
        migrations.AddField(
            model_name='sourcecitationref',
            name='item_type',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalItemType'),
        ),
        migrations.AddField(
            model_name='sourcecitationonlineref',
            name='item_type',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalItemType'),
        ),
        migrations.AddField(
            model_name='revisionjoinstg',
            name='source_citation',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='common.SourceCitationStgRef'),
        ),
        migrations.AddField(
            model_name='revisionjoinonline',
            name='source_citation',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='common.SourceCitationOnlineRef'),
        ),
        migrations.AddField(
            model_name='revisionjoin',
            name='source_citation',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='common.SourceCitationRef'),
        ),
        migrations.AddField(
            model_name='publicationsourcerelstg',
            name='source',
            field=models.ForeignKey(db_column='statisticalsourcetype_id', on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalSourceType'),
        ),
        migrations.AddField(
            model_name='publicationsourcerel',
            name='source',
            field=models.ForeignKey(db_column='statisticalsourcetype_id', on_delete=django.db.models.deletion.CASCADE, to='common.StatisticalSourceType'),
        ),
        migrations.AddField(
            model_name='publicationsourcerel',
            name='source_citation_ref',
            field=models.ForeignKey(db_column='sourcecitationref_id', on_delete=django.db.models.deletion.CASCADE, to='common.SourceCitationRef'),
        ),
        migrations.AddField(
            model_name='protocolrevisionjoinstg',
            name='source_citation',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='common.ProtocolSourceCitationStgRef'),
        ),
        migrations.AddField(
            model_name='protocolmethodstgrel',
            name='source_citation',
            field=models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, related_name='protocols', to='common.ProtocolSourceCitationStgRef'),
        ),
        migrations.AddField(
            model_name='protocolmethodrel',
            name='source_citation',
            field=models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, related_name='protocols', to='common.SourceCitationRef'),
        ),
        migrations.AddField(
            model_name='protocolmethodonlinerel',
            name='source_citation',
            field=models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, related_name='protocols', to='common.SourceCitationOnlineRef'),
        ),
        migrations.AddField(
            model_name='methodstg',
            name='method_subcategory',
            field=models.ForeignKey(blank=True, help_text='The "Method subcategory" describes the class of analytes that are measured by the method. Choose the appropriate subcategory (e.g., INORGANIC, RADIOCHEMICAL, MICROBIOLOGICAL) from the list of values. If your method does not fit into the available subcategories, or if you have a question about the meaning of the subcategories, contact the NEMI manager.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MethodSubcategoryRef'),
        ),
        migrations.AddField(
            model_name='methodstg',
            name='method_type',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.MethodTypeRef'),
        ),
        migrations.AddField(
            model_name='methodstg',
            name='relative_cost',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='common.RelativeCostRef'),
        ),
        migrations.AddField(
            model_name='methodstg',
            name='source_citation',
            field=models.ForeignKey(help_text='The "Source citation" is a reference to the publication/volume that contains the method. Choose the appropriate source citation (e.g., ASTM_11_01 - ASTM Vol. 11.01, MCAWW - Methods of Chemical Analysis for Water and Waste) from the list of values.\nIf your method does not fit into the available citations, contact the NEMI manager at jsulliv@usgs.gov.\nNOTE: Source citation acroynms are not always obvious -- always consult the Source citation list prior to selection one.', on_delete=django.db.models.deletion.CASCADE, to='common.SourceCitationRef'),
        ),
        migrations.AddField(
            model_name='methodstg',
            name='waterbody_type',
            field=models.ForeignKey(blank=True, db_column='waterbody_type', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.WaterbodyTypeRef'),
        ),
        migrations.AddField(
            model_name='methodonline',
            name='method_source',
            field=models.ForeignKey(blank=True, help_text='The "Method source" is the organization that publishes a method.\nIF a method has a publication source THEN include it ELSE do not include method in database', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MethodSourceRef'),
        ),
        migrations.AddField(
            model_name='methodonline',
            name='method_subcategory',
            field=models.ForeignKey(blank=True, help_text='The "Method subcategory" describes the class of analytes that are measured by the method. Choose the appropriate subcategory (e.g., INORGANIC, RADIOCHEMICAL, MICROBIOLOGICAL) from the list of values. If your method does not fit into the available subcategories, or if you have a question about the meaning of the subcategories, contact the NEMI manager.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MethodSubcategoryRef'),
        ),
        migrations.AddField(
            model_name='methodonline',
            name='method_type',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.MethodTypeRef'),
        ),
        migrations.AddField(
            model_name='methodonline',
            name='relative_cost',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='common.RelativeCostRef'),
        ),
        migrations.AddField(
            model_name='methodonline',
            name='source_citation',
            field=models.ForeignKey(help_text='The "Source citation" is a reference to the publication/volume that contains the method. Choose the appropriate source citation (e.g., ASTM_11_01 - ASTM Vol. 11.01, MCAWW - Methods of Chemical Analysis for Water and Waste) from the list of values.\nIf your method does not fit into the available citations, contact the NEMI manager at jsulliv@usgs.gov.\nNOTE: Source citation acroynms are not always obvious -- always consult the Source citation list prior to selection one.', on_delete=django.db.models.deletion.CASCADE, to='common.SourceCitationRef'),
        ),
        migrations.AddField(
            model_name='methodonline',
            name='waterbody_type',
            field=models.ForeignKey(blank=True, db_column='waterbody_type', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.WaterbodyTypeRef'),
        ),
        migrations.AddField(
            model_name='method',
            name='method_source',
            field=models.ForeignKey(blank=True, help_text='The "Method source" is the organization that publishes a method.\nIF a method has a publication source THEN include it ELSE do not include method in database', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MethodSourceRef'),
        ),
        migrations.AddField(
            model_name='method',
            name='method_subcategory',
            field=models.ForeignKey(blank=True, help_text='The "Method subcategory" describes the class of analytes that are measured by the method. Choose the appropriate subcategory (e.g., INORGANIC, RADIOCHEMICAL, MICROBIOLOGICAL) from the list of values. If your method does not fit into the available subcategories, or if you have a question about the meaning of the subcategories, contact the NEMI manager.', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.MethodSubcategoryRef'),
        ),
        migrations.AddField(
            model_name='method',
            name='method_type',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='common.MethodTypeRef'),
        ),
        migrations.AddField(
            model_name='method',
            name='relative_cost',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='common.RelativeCostRef'),
        ),
        migrations.AddField(
            model_name='method',
            name='source_citation',
            field=models.ForeignKey(help_text='The "Source citation" is a reference to the publication/volume that contains the method. Choose the appropriate source citation (e.g., ASTM_11_01 - ASTM Vol. 11.01, MCAWW - Methods of Chemical Analysis for Water and Waste) from the list of values.\nIf your method does not fit into the available citations, contact the NEMI manager at jsulliv@usgs.gov.\nNOTE: Source citation acroynms are not always obvious -- always consult the Source citation list prior to selection one.', on_delete=django.db.models.deletion.CASCADE, to='common.SourceCitationRef'),
        ),
        migrations.AddField(
            model_name='method',
            name='waterbody_type',
            field=models.ForeignKey(blank=True, db_column='waterbody_type', null=True, on_delete=django.db.models.deletion.CASCADE, to='common.WaterbodyTypeRef'),
        ),
        migrations.AddField(
            model_name='legacyuseraccount',
            name='user_role',
            field=models.ForeignKey(db_column='user_role', on_delete=django.db.models.deletion.CASCADE, to='common.UserRole'),
        ),
        migrations.AddField(
            model_name='analytemethodjnstg',
            name='dl_units',
            field=models.ForeignKey(db_column='dl_units', on_delete=django.db.models.deletion.DO_NOTHING, to='reference.DlUnitsDom'),
        ),
        migrations.AddField(
            model_name='analytemethodjnstg',
            name='method',
            field=models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, related_name='analytes', to='common.MethodStg'),
        ),
        migrations.AddField(
            model_name='analytemethodjnstg',
            name='precision_units',
            field=models.ForeignKey(blank=True, db_column='precision_units', null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='reference.PrecisionUnitsDom'),
        ),
        migrations.AddField(
            model_name='analytemethodjnonline',
            name='dl_units',
            field=models.ForeignKey(db_column='dl_units', on_delete=django.db.models.deletion.DO_NOTHING, to='reference.DlUnitsDom'),
        ),
        migrations.AddField(
            model_name='analytemethodjnonline',
            name='method',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='analytes', to='common.MethodOnline'),
        ),
        migrations.AddField(
            model_name='analytemethodjnonline',
            name='precision_units',
            field=models.ForeignKey(blank=True, db_column='precision_units', null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='reference.PrecisionUnitsDom'),
        ),
        migrations.AddField(
            model_name='analytemethodjn',
            name='dl_units',
            field=models.ForeignKey(db_column='dl_units', on_delete=django.db.models.deletion.DO_NOTHING, to='reference.DlUnitsDom'),
        ),
        migrations.AddField(
            model_name='analytemethodjn',
            name='method',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='analytes', to='common.Method'),
        ),
        migrations.AddField(
            model_name='analytemethodjn',
            name='precision_units',
            field=models.ForeignKey(blank=True, db_column='precision_units', null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='reference.PrecisionUnitsDom'),
        ),
        migrations.AlterUniqueTogether(
            name='revisionjoinstg',
            unique_together=set([('method', 'revision_information', 'source_citation')]),
        ),
        migrations.AlterUniqueTogether(
            name='revisionjoinonline',
            unique_together=set([('method', 'revision_information')]),
        ),
        migrations.AlterUniqueTogether(
            name='revisionjoin',
            unique_together=set([('method', 'revision_information', 'source_citation')]),
        ),
        migrations.AlterUniqueTogether(
            name='protocolrevisionjoinstg',
            unique_together=set([('method', 'revision_information', 'source_citation')]),
        ),
        migrations.AlterUniqueTogether(
            name='analytemethodjnstg',
            unique_together=set([('method', 'analyte')]),
        ),
        migrations.AlterUniqueTogether(
            name='analytemethodjnonline',
            unique_together=set([('method', 'analyte')]),
        ),
        migrations.AlterUniqueTogether(
            name='analytemethodjn',
            unique_together=set([('method', 'analyte')]),
        ),
    ]
